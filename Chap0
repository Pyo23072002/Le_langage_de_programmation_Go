Préface

« Go est un langage de programmation open-source qui permet de créer facilement des logiciels simples, fiables et performants. »
 (depuis le site web de go, golang.org)
 
Go a été créé en Septembre 2007 par Robert Griesemer, Rob Pike, et Ken Thompson, tous chez Google, et a été annoncé en Novembre 2009. Les objectifs de ce langage et des outils l’accompagnant étaient d’être expressif, performant lors de la compilation et l’exécution, et efficace dans l’écriture de programmes fiables et robustes.  
Go présente une similarité de surface avec C et, comme C, est un outil pour des programmeurs professionnels, qui leur permet de produire un effet maximal avec un minimum de moyens. Mais Go offre beaucoup plus que seulement une version mise à jour de C. Il emprunte et adapte de bonnes idées de plusieurs autres langages, tout en évitant les fonctionnalités qui mènent à du code complexe et peu fiable. Ses fonctionnalités pour la programmation concurrente sont nouvelles et efficaces, et son approche de l’abstraction de données et la programmation orientée-objet est tout à fait nouvelle. Nous pouvons aussi ajouter qu'il intègre une gestion automatique de la mémoire via un ramasse-miettes (« garbage collection »).
Go est spécialement adapté pour construire des infrastructures comme des réseaux de serveurs, et des outils et systèmes pour les programmeurs, mais il est réellement polyvalent et trouve des usages dans des domaines aussi divers que la visualisation de données, des applications mobiles et l’apprentissage automatique (“machine learning”). Il est devenu populaire pour remplacer des langages de scriptes non-typés parce qu’il concilie expressivité et sécurité : les programmes Go s’exécutent généralement plus rapidement que des programmes écrits dans des langages dynamiques et souffrent de beaucoup moins de plantages due à des erreurs de types inattendues.
Go est un projet open-source: le code source de son compilateur, ses bibliothèques, et ses outils sont ouverts et disponibles à tous. Les contributions au projet viennent d’une communauté active partout dans le monde. Go s’exécute sur des systèmes UNIX – Linux, FreeBSD, OpenBSD, Mac OS X –, sur Plan 9 et sur Microsoft Windows. Un programme écrit pour l’un ces environnements fonctionne en général sans modifications sur les autres.
Ce livre a pour but de vous aider à commencer à utiliser Go efficacement et correctement dès le début, en bénéficiant des fonctionnalités du langage et les librairies standard du langage Go afin d’écrire des programmes clairs, idiomatiques et performants.
Les origines du langage Go
Tout comme les espèces biologiques, les langages réussis engendrent une descendance qui incorpore les avantages de leurs ancêtres; à côté de ça, le métissage mène parfois à de surprenantes forces; et, occasionnellement, une fonctionnalité radicalement nouvelle surgit. Nous pouvons beaucoup apprendre sur pourquoi un langage est ce qu’il est et pour quel environnement il est adapté en étudiant ces influences.  
Le schéma ci-dessous montre les influences les plus importantes de langages de programmation précédent sur la conception de Go : 

 
Go est parfois décrit comme un langage « de type C » ou un « C pour le 21ème siècle ». De C, Go a hérité de la syntaxe des expressions, des structures de contrôle, des types de données de bases, du passage de paramètre par valeur lors d’appels de fonctions, des pointeurs et par-dessus tout la capacité du C à faire des programmes qui compilent en code machine performant et coopèrent naturellement avec les abstractions des systèmes d’exploitations courant.
Mais il existe d’autres ancêtres dans l’arbre généalogique de Go. Un courant d’influence majeur vient des langages de Niklaus Wirth, en commençant par Pascal. Modula-2 a ensuite inspiré le concept de paquet. Oberon a éliminé la distinction faite entre le module d’interfaces des fichiers, et le module d’implémentation des fichiers. Oberon-2 a influencé la syntaxe pour les paquets (“packages”), les imports, et la déclaration, puis finalement Object Oberon a fourni la syntaxe pour la déclaration de méthodes.
Une autre lignée dans les ancêtres de Go, qui l’a fait se démarquer des autres langages de programmation récents, est une série de recherche peu connue sur les langages, développée aux Laboratoires Bell, tous inspiré par le concept de processus séquentiels communicants (CSP - “Communicating sequential processes”) de Tony Hoare dans son article précurseur sur les fondements de la concurrence. En CSP, un programme est composé de processus parallèles qui n’ont pas d'état partagé; lesdits processus communiquent et se synchronisent en utilisant des canaux. Mais le CSP de Hoare pour décrire les concepts fondamentaux de la concurrence était un langage formel, et non pas un langage de programmation pour écrire des programmes exécutables.
Rob Pike ainsi que d’autres ont commencé à expérimenter avec des implémentations réelles de CSP. Le premier d’entre eux fut nommé Squeak (« Un langage pour communiquer avec une souris », squeak en anglais signifiant le couinement de la souris). C’est un langage qui gère les événements liés à la souris et au clavier, avec des canaux créés statiquement. Il fut suivi par le Newsqueak, qui offrît une syntaxe de type C des “déclarations” et des “expressions” et une expression des “types” semblable au Pascal. C’était un langage purement fonctionnel avec un ramasse-miettes (Garbage collector), visant, là aussi, à gérer les événements venant de la souris, du clavier et des fenêtres. Les canaux sont devenus des valeurs de première classe qui peuvent être créées dynamiquement et stockées dans des variables.
Le système d’exploitation Plan 9 a développé ces idées dans un langage appelé Alef. Alef a essayé de faire de Newsqueak un langage de programmation système viable, mais, n’offrant pas de gestion de mémoire, la concurrence était trop pénible à utiliser.
Différents éléments de Go montrent l’influence occasionnelle d’autres langages. Par exemple, “iota” est librement inspiré de APL, et le champ lexical avec les fonctions imbriquées provient de Scheme (et la plupart des langages depuis). Go apporte aussi des évolutions. Les “slices” de Go sont innovantes et fournissent des tableaux dynamiques avec un accès direct efficace mais permettent aussi des arrangements de partage sophistiqués qui rappellent les listes chaînées. L’instruction “defer” a été introduite par Go.

LE PROJET GO
Tous les langages de programmation sont le reflet de la manière de programmer de leurs créateurs, ce qui inclut souvent une partie majeure de réactions aux manquements des langages précédents. Le projet de Go vient et a été le résultat de frustrations avec plusieurs systèmes de logiciel chez Google qui souffraient d’une explosion de leur complexité. (Ce problème n’est bien sûr pas inhérent à Google).
Comme Rob Pike l’a observé : “La complexité est multiplicative”: réparer un problème en rendant une partie du système plus complexe ajoute, lentement mais sûrement, de la complexité aux autres parties. Avec la pression constante d’ajouter des fonctionnalités, options et configurations, et d’expédier le code rapidement, il est facile de négliger la simplicité, même si à long terme cette simplicité est la clé d’un bon logiciel.
La simplicité requiert davantage de travail au début d’un projet afin de de réduire une idée à sa plus stricte forme et davantage de discipline tout du long du projet afin de distinguer les bons changements des changements mauvais ou pernicieux. Avec les efforts nécessaires, un bon changement peut être implémenté sans compromettre ce que Fred Brooks a appelé le "Concept d’intégrité” d’un projet. A l’inverse, un mauvais changement  le compromet et un changement pernicieux tend à troquer la simplicité pour une propriété proche mais superficielle : la facilité. En somme, un système ne peut, en grandissant, rester fiable, sécurisé et cohérent, seulement s’il respecte une simplicité de conception.

Le projet Go inclut le langage lui-même, ses outils et bibliothèque standards et, pour finir; un dernier point mais non le moindre, une culture de la simplicité des plus radicales. En tant que récent langage de haut niveau, Go à l'avantage du recul et les bases ont été bien posées : il possède un ramasse-miette, un système de paquets, des fonctions de première classe, une portée lexicale une interface d’appel système, et des chaînes de caractère immuables dans lesquelles le texte est généralement encodé en UTF-8. En revanche, il a comparativement peu de fonctionnalités et n’envisage d’en rajouter davantage. Il n’a, par exemple, pas de conversion numérique implicite, de constructeur ou destructeur, pas de redéfinition d’opérateur, pas de valeurs par défaut des paramètres, pas d’héritage, pas d’exception, pas de macro, pas d’annotation de fonction, et pas de stockage local sur un thread. Le langage est mature et stable, et garantit une compatibilité ascendante : les vieux programmes en Go peuvent être compilés et exécutés sur de nouvelles versions de compilateurs et de bibliothèques standards.
Go a assez de système de type pour éviter la plupart des erreurs d'inattention qui pèsent sur les programmeurs de langages dynamique, mais il a un système de type plus simple comparés à d’autres langages typés. Cette approche peut parfois mener à des parties isolées de programmation non-typée dans un environnement typé et les programmeurs de Go ne vont pas aller aussi loin que les programmeurs de C++ ou Haskell peuvent faire pour exprimer des propriétés de sécurité basées sur des types. Mais en pratique Go donne aux programmeurs les avantages, en termes de sécurité et de performance d'exécution, d’un système fortement typé sans subir la friction d’un système de type complexe.
Go encourage la prudence vis-à-vis de la conception de systèmes informatiques contemporains, et particulièrement l’importance de la localité. Ses types de données intégrés et la plupart des structures de données des bibliothèques sont faits pour travailler naturellement sans initialisation explicite ou de constructeurs implicites, de sorte que  relativement peu d’allocation mémoire et d’écritures de mémoires sont cachées dans le code. Les types composites de Go (struct et arrays) contiennent les éléments directement, ce qui requiert moins de stockage, moins d’allocations et moins de déréférencement que des langages utilisant des éléments via une indirection. Et comme un ordinateur moderne est une machine parallèle, Go a des fonctionnalités de concurrence, basées sur le CSP, comme mentionné plus tôt. Go offre des threads "légers" : les goroutines, qui ne sont pas chacune implémentées directement sur un thread du système d'exploitation. Les piles à taille variable des goroutines occupent peu de mémoire lors de leur création: il est alors raisonnable d'en créer un million, si besoin.
La bibliothèque standard de Go, souvent décrite comme venant “batteries incluses”, fournit des éléments de bases pratiques et des APIs pour, les input et output, la gestion de texte, l’édition graphique, la cryptographie, le réseau, les applications distribuées  et supportant la plupart des formats de fichier et protocoles standard. Les bibliothèques et les outils mettent en place nombre de conventions pour réduire le besoin de configuration et d’explication, ce qui simplifie la logique des programmes et améliore la cohérence des programmes Go, ce qui facilite l’apprentissage. Les projets construits à l'aide de l'outil go n'utilisent que des noms de fichiers et d'identifiants et parfois un commentaire conventionnel pour déterminer les bibliothèques, les exécutables, les tests, les benchmarks, les exemples, les variantes spécifiques à une plate-forme et la documentation d'un projet ; le fichier source Go contient lui-même les spécifications de construction.
Organisation du livre 
Nous partons du principe que vous avez déjà programmé dans un ou plusieurs autres langages, qu’ils se compilent comme le C, C++, et Java, ou s'interprètent comme Python, Ruby, et JavaScript, nous n’allons donc pas tout expliquer comme si vous étiez un total débutant. La syntaxe, à la première approche, sera familière, comme le sont les variables et constantes, les expressions, les tests et les fonctions.

Le Chapitre 1 est un tutoriel sur les instructions de base de Go, présentées à travers une douzaine de programmes pour les tâches de base comme l’écriture et la lecture de fichier, le formatage de texte, la création d’images, et la communication avec Internet du côté client et serveur.
Le Chapitre 2 décrit les éléments structurels d’un programme en Go - déclarations, variables, créations de types, paquets et dossiers, et la portée des variables. Le Chapitre 3 aborde les nombres, les booléens, les types composites, les chaînes de caractères, les constantes et explique comment travailler avec l’Unicode. Le Chapitre 4 décrit les types composites, qui sont des types formés à partir de  types simples à l'aide de tableaux (arrays), “map”, structs, et “slices”, les slices qui, en Go, sont les listes de taille variable. Le Chapitre 5 couvre les fonctions et aborde la gestion des erreurs, les instructions panic, recover et defer.
Les chapitres 1 à 5 sont sur les bases, les choses qui sont communes à n’importe quel langage impératif généraliste. La syntaxe et le style de Go différent parfois d’autres langages mais la plupart des programmeurs intégreront rapidement ces légères différences. Les chapitres restants se focalisent sur les sujets où l’approche de Go est moins conventionnelle : les méthodes, les interfaces, la concurrence, les paquets, les tests et la réflexion.
Go a une approche inhabituelle de la programmation orientée objet; Il y a n’y a pas de hiérarchies de classe ou même, de classes. Les comportements complexes d'objets sont créés depuis de plus simples comportements par composition et non par héritage. Les méthodes peuvent être associées avec n’importe lequel des types définis par l’utilisateur, pas seulement les structs et les relations entre les types concret et les types abstrait (les interfaces) sont implicites, de sorte qu’un type concret peut satisfaire une interface que le concepteur du type n’avait pas connaissance. Les méthodes sont vues dans le Chapitre 6 et les interfaces dans le Chapitre 7.
Le Chapitre 8 présente l’approche de la concurrence en Go, cette approche est basée sur une idée de processus de communication séquentiels (CSP), incarnée par les goroutines et les canaux. Le Chapitre 9 explique les aspects plus traditionnels de la concurrence, basés sur les variables partagées.
Le Chapitre 10 décrit les paquets, le mécanisme pour organiser les bibliothèques. Ce chapitre montre aussi comment utiliser efficacement “l’outil Go” afin de compiler, tester, référencer, formater des programmes, documenter et encore beaucoup d’autres tâches, le tout en une seule commande.
Le Chapitre 11 traite des tests, où Go adopte une approche particulièrement légère, évitant l’introduction de concepts et d’abstractions et préférant de simples bibliothèques et outils. Les bibliothèques de test fournissent une base sur laquelle il est possible de construire des abstractions plus complexes si nécessaire.
Le Chapitre 12 parle de la réflexion, la possibilité pour un programme d’examiner sa propre représentation durant son exécution. La réflexion est un outil puissant, mais qui doit être utilisé avec précaution; ce chapitre explique comment trouver le bon équilibre en montrant comment elle est utilisée pour implémenter certaines bibliothèques importantes de Go. Le Chapitre 13 explique les détails gores, de la programmation bas niveau qui utilise le paquet “unsafe”, pour contourner le système de type de Go, et quand cela est approprié.
Chaque chapitre a un nombre d’exercices que vous pouvez utiliser pour tester votre compréhension de Go, et pour explorer les extensions et alternatives aux exemples du livre.
Tous sauf les plus triviaux des exemples de code présent dans ce livre sont téléchargeables sur le dépôt public de Git à l’adresse gopl.io. Chaque exemple y est identifié par le chemin d’importation de son paquet et peut être facilement récupéré, construit et installé en utilisant la commande “go get”. Entre autres, vous aurez besoin de choisir un répertoire afin qu’il devienne votre environnement de travail en Go, et, de même, définir la variable d'environnement GOPATH pour pointer vers celui-ci. L’outil de go créera le répertoire si nécessaire. Ci-dessous, un exemple :
	$  export GOPATH=$HOME/gobook 		#  choose workspace directory
	$  go get gopl.io/ch1/helloworld		#  fetch, buil, install
	$  $GOPATH/bin/helloworld			#  run
	Hello, BF
Pour exécuter ces exemples, vous aurez au moins besoin de la version 1.5 de Go. 
	$  go version
	go version go1.5 linux/amd64

Suivez les instructions à l’adresse https://golang.org/doc/install si votre outil go est plus vieux que la version 1.5 ou manquant.

Où trouver plus d’informations
La meilleure source pour plus d’informations sur le langage de programmation Go est le site web officiel, https://go.dev, qui donne accès à la documentation, ce qui englobe The Programming Language Specification, des paquets standard, etc. Il y a aussi des tutoriels sur comment écrire du Go et comment bien l’écrire, ainsi qu’une grande variété de ressources, écrites et audiovisuelles, en ligne qui seront des complément de valeurs à ce livre. En particulier, le blog du langage Go -https://go.dev/blog/ publie parmi les meilleurs articles sur le langage Go, avec des articles sur l’état du langage, les plans pour le futur, des rapports sur des conférences et des explications en profondeur sur une grande variété de sujets reliés à Go.

Un des aspects les plus utiles de l’accès à Go en ligne (et une limitation regrettable d’un livre papier) est la capacité d'exécuter des programmes en Go depuis des pages web qui les décrivent. Cette fonctionnalité est fournie par le “Bac-à-Sable” de Go à l’adresse web play.golang.org, et peut être intégrée dans d’autres pages web, à l’instar de la page d’accueil de golang.org ou encore la page de documentation fournie par l’outil godoc.
Le Bac-à-Sable rend facile le lancement de simples expérimentations afin de vérifier la compréhension d’un point de syntaxe, de sémantique, ou d’une bibliothèque de paquets avec un court programme, et, la plupart du temps prend la place d’une boucle de lecture-évaluation-affichage (REPL) dans d’autres langages. De plus, ses URLs persistantes sont un bon moyen de partager des extraits de code en Go avec d’autres personnes, afin de reporter des bugs ou faire des suggestions.
Construite sur les bases du Bac-à-Sable, le Go Tour (Visite de Go), à l’adresse web tour.golang.org, est une séquence de courtes leçons interactive sur les idées basiques et constructions basiques de go, en somme : une marche guidée au travers du langage.

Le principal défaut du Bac-à-Sable et du Tour est qu’ils autorisent seulement l'importation des bibliothèques standards, de plus la plupart des fonctionnalités des bibliothèques- comme la mise en réseau, sont restreintes pour des raisons pratiques ou sécuritaires. Ils requièrent aussi un accès à Internet afin de compiler et exécuter chaque programme. Donc pour des expérimentations plus élaborées, vous devrez exécuter vos programmes de Go sur votre propre ordinateur. Heureusement, le processus de téléchargement est simple, cela ne devrait donc pas prendre plus de quelques minutes pour récupérer votre distribution de Go depuis golang.org et commencer à écrire et exécuter des programmes en Go par vous même.
Depuis que Go est un projet  open-source, vous pouvez lire le code de n’importe lequel type ou fonction dans la bibliothèque standard à l’adresse web https://golang.org/pkg; c’est le même code que celui qu’il y a dans une partie de votre propre distribution. Utilisez-la pour comprendre comment quelque chose fonctionne , ou pour répondre à des questions sur des points de détails, ou plus simplement pour voir comment des experts écrivent du très bon code Go.

Remerciements
Rob Pike et Russ Cox, les membres principaux de l’équipe de Go, ont lu le manuscrit de nombreuses fois avec une grande attention; leurs commentaires sur tout, depuis le choix des mots jusqu’à la structure et l’organisation ont été inestimables. Pendant la préparation de la traduction japonaise, Yoshiki Shibata a été bien au-delà de  son devoir; son œil méticuleux a repéré de nombreuses incohérences dans le texte Anglais et d’erreurs dans le code. D’autre part, nous apprécions fortement la rigueur des revues, et des critiques sur l'entièreté du manuscrit de Brian Goetz, Corey Kosak, Arnold Robbins, Josh Bleecher Snyder, et Peter Weinberger.
Nous sommes ensuite redevables à Sameer Ajmani, Ittai Balaban, David Crawshaw, Billy Donohue, Jonathan Feinberg, Andrew Gerrand, Robert Griesemer, John Linderman, Minux Ma, Bryan Mills, Bala Natarajan, Cosmos Nicolaou, Paul Staniforth, Nigel Tao, et Howard Trickey pour leurs suggestions nombreuses et utiles. Nous remercions aussi David Brailsford et Raph Levien pour leur conseil en composition et traitement de texte.
Notre éditeur Greg Doench chez Addison-Wesley qui a initialement lancé le projet et n’a cessé de nous soutenir depuis. De même l’équipe de production de AW - John Fuller, Dayna Isley, Julie Nahil, Chuti Praseertsith et Barbara Wood-- a été exceptionnelle; aucun auteur ne pourrait espérer meilleur support.
Alan Donovan souhaite remercier : Sameer Ajmani, Chris Demetriou, Walt Drummond, et Reid Tatge de chez Google pour lui avoir donner le temps d’écrire; Stephen Donovan, pour son avis et soutien en temps voulu; et par dessus tout, sa femme Leila Kamezi, pour son enthousiasme sans relache et son soutien sans faille au projet, malgré les longues heures de distraction et d’absence de la vie familale que cela a impliqué.
Brian Kernighan est profondément reconnaissant envers ses amis et ses collègues pour leur patience et tolérance tandis qu’il avançait doucement le long du chemin de la compréhension, et spécialement à sa femme Meg, qui a été, une infaillible supporteur de la redaction de livre et de tant d’autres choses.
New York
Octobre 2015

